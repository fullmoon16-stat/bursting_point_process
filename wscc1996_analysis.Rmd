---
title: "WSCC 1996 cascading failure analysis"
output: html_document
---
This R Markdown file reproduces Figures 3–6 and Tables 2–5 in the paper
using the data `wscc1996_cascading_events.csv`.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r include=FALSE}
library(tidyverse)
library(lubridate)
library(gridExtra)
library(DEoptim)
library(latex2exp)
```


# Load data

```{r include=FALSE}
df <- read.csv("wscc1996_cascading_events.csv", header = TRUE)
```

```{r}
# the cascading failures until the time of explosion 
df2 = df[-c(39:54),]; dim(df2) 
```

## 1. Data and empirical plots (Figures 3–4)

```{r}
# (t,N(t))
g1 = ggplot(df, aes(x = second, y = sequence)) +
  geom_step(color = "blue", linewidth = 1.1) +
  labs(
    #title = "(A) Original data",
    x = "Time (in sec)",
    y = "Cumulative number of failures N(t)"
  ) + 
  coord_cartesian(xlim = c(5950, NA)) + 
  scale_y_continuous(breaks = seq(0, 54, by = 10), limits = c(0, 54)) +
  scale_x_continuous(breaks = seq(5600, 6500, by = 100)) +
  theme_minimal() + 
  theme(
    #panel.grid.major = element_line(color = "grey90"),   # 약한 주격자선
    panel.grid.minor = element_blank(),
    axis.title = element_text(size = 11),
    axis.text = element_text(size = 10),
    plot.title = element_text(size = 12, hjust = 0)
  )


g2 = ggplot(df2, aes(x = second, y = sequence)) +
  geom_step(color = "blue", linewidth = 1.1) +
  labs(
    #title = "(B) Truncated data",
    x = "Time (in sec)",
    y = "Cumulative number of failures N(t)"
  ) + 
  coord_cartesian(xlim = c(5950, NA)) + 
  scale_y_continuous(breaks = seq(0, 40, by = 5)) +
  scale_x_continuous(breaks = seq(5600, 6500, by = 100)) +
  theme_minimal() + 
  theme(
    #panel.grid.major = element_line(color = "grey90"),   # 약한 주격자선
    panel.grid.minor = element_blank(),
    axis.title = element_text(size = 11),
    axis.text = element_text(size = 10),
    plot.title = element_text(size = 12, hjust = 0)
  )

grid.arrange(g1, g2, ncol=2)
```

# Likelihood

```{r}
df2 = df2[-1,]
nrow(df2)
attach(df2)
```

## 2. Model fitting with truncated data (Table 2)

### Geometrc process

```{r}
set.seed(1234)
fn1 = function(par){
  
  f=rep(0,nrow(df2))
  lambda = exp(par[1])
  a = exp(par[2])
  
  for(i in 1:nrow(df2)){
    f[i] = dexp(Tn[i],rate = lambda*a^(i))
  }
  ll = sum(log(f))
  return(ll)
}

de_result <- DEoptim(
    fn = function(par) -fn1(par),
    lower = c(-10,-0.1),
    upper = c(-0.1,1),
    control = list(NP = 10 * 2, itermax = 100, trace = F)
)

opt1 = optim(par=de_result$optim$bestmem,fn1,control=list(fnscale=-1))
opt1 = optim(par=c(opt1$par[1],opt1$par[2]),fn1,control=list(fnscale=-1))
opt1 = optim(par=c(opt1$par[1],opt1$par[2]),fn1,control=list(fnscale=-1))
exp(opt1$par) # mle
opt1$value # log-likelihood 
aic_1 = -2*opt1$value + 2*length(opt1$par);aic_1 # AIC 
bic_1 = -2*opt1$value + log(nrow(df2))*length(opt1$par);bic_1 # BIC
```


### EGPP with r(n)=(1+n)^delta

```{r}
set.seed(2025)
fn2 = function(par){
  
  lambda = exp(par[1])
  delta = exp(par[2])
  
  index = 1:nrow(df2)
  
  ll1 = nrow(df2)*log(lambda) + delta*sum(log((1+index)))
  ll2 = lambda * sum((1+index)^delta * Tn)

  loglik <- ll1-ll2
  
  return(loglik)
}

de_result <- DEoptim(
    fn = function(par) -fn2(par),
    lower = c(-15,-1),
    upper = c(-3,1),
    control = list(NP = 10 * 2, itermax = 100, trace = F)
)

opt2 = optim(par=de_result$optim$bestmem,fn2,control=list(fnscale=-1))
opt2 = optim(par=c(opt2$par[1],opt2$par[2]),fn2,control=list(fnscale=-1))
opt2 = optim(par=c(opt2$par[1],opt2$par[2]),fn2,control=list(fnscale=-1))
exp(opt2$par) # mle
opt2$value # log-likelihood 
aic_2 = -2*opt2$value + 2*length(opt2$par);aic_2 # AIC 
bic_2 = -2*opt2$value + log(nrow(df2))*length(opt2$par);bic_2 # BIC
```

### EGPP with r(n)=q^n

```{r}
set.seed(2025)
fn3 = function(par){
  
  lambda = exp(par[1])
  q = exp(par[2])
  
  index = (1:nrow(df2))-1
  
  ll1 = sum(log(q^index * lambda))
  ll2 = sum(q^index * lambda * Tn)

  loglik <- ll1-ll2
  
  return(loglik)
}

de_result <- DEoptim(
    fn = function(par) -fn3(par),
    lower = c(-10,-0.1),
    upper = c(-0.1,1),
    control = list(NP = 10 * 2, itermax = 100, trace = F)
)

opt3 = optim(par=de_result$optim$bestmem,fn3,control=list(fnscale=-1))
opt3 = optim(par=c(opt3$par[1],opt3$par[2]),fn3,control=list(fnscale=-1))
opt3 = optim(par=c(opt3$par[1],opt3$par[2]),fn3,control=list(fnscale=-1))
exp(opt3$par) # mle
opt3$value # log-likelihood 
aic_3 = -2*opt3$value + 2*length(opt3$par);aic_3 # AIC 
bic_3 = -2*opt3$value + log(nrow(df2))*length(opt3$par);bic_3 # BIC
```

### EGPP with r(n)=(1+n^3)^delta

```{r}
set.seed(2025)
fn4 = function(par){
  
  lambda = exp(par[1])
  delta = exp(par[2])
  
  index = 1:nrow(df2)
  
  #ll1 = sum(log((1+index^5)^delta * lambda))
  ll1 = nrow(df2)*log(lambda) + delta*sum(log((1+index^3)))
  ll2 = lambda * sum((1+index^3)^delta * Tn)

  loglik <- ll1-ll2
  
  return(loglik)
}

de_result <- DEoptim(
    fn = function(par) -fn3(par),
    lower = c(-15,-1),
    upper = c(-3,1),
    control = list(NP = 10 * 2, itermax = 100, trace = F)
)

opt4 = optim(par=de_result$optim$bestmem,fn4,control=list(fnscale=-1))
opt4 = optim(par=c(opt4$par[1],opt4$par[2]),fn4,control=list(fnscale=-1))
opt4 = optim(par=c(opt4$par[1],opt4$par[2]),fn4,control=list(fnscale=-1))
opt4 = optim(par=c(opt4$par[1],opt4$par[2]),fn4,control=list(fnscale=-1))
exp(opt4$par) # mle
opt4$value # log-likelihood 
aic_4 = -2*opt4$value + 2*length(opt4$par);aic_4 # AIC 
bic_4 = -2*opt4$value + log(nrow(df2))*length(opt4$par);bic_4 # BIC
```

### Hawkes process

```{r}
second = c(0,second)
second
```

#### a*exp(-bt)
```{r}
Tmax = max(second)
set.seed(1234)
fn5 = function(par){
  
  lambda = exp(par[1])
  a = exp(par[2])
  b = exp(par[3])
  
  ### 첫 항: sum of log intensities ###
  
  log_intensity = rep(0,nrow(df2))
  for (i in 1:nrow(df2)) {
      past_deltas <- second[i+1] - second[1:(i)]
      log_intensity[i] <- lambda + sum(a * exp(-b * past_deltas))
  }
  log_intensity_sum <- sum(log(log_intensity))
  
  ### 두 번째 항 ###
  compensator_lambda <- lambda * Tmax

  ### 세 번째 항 ###
  compensator_phi <- (a / b) * sum(1-exp(-b * (Tmax - second)))

  ### 전체 log-likelihood ###
  loglik <- log_intensity_sum - compensator_lambda - compensator_phi
  
  return(loglik)
}

de_result <- DEoptim(
    fn = function(par) -fn5(par),
    lower = log(c(0.00001,0.01,0.01)),
    upper = log(c(1,1,1)),
    control = list(itermax = 100, trace = F)
)

opt5 = optim(par=de_result$optim$bestmem,fn5,control=list(fnscale=-1))
opt5 = optim(par=c(opt5$par[1],opt5$par[2],opt5$par[3]),fn5,control=list(fnscale=-1))
opt5 = optim(par=c(opt5$par[1],opt5$par[2],opt5$par[3]),fn5,control=list(fnscale=-1))
```


# Monte Carlo
## Simulate process

```{r}
#------------------------------------------------------------
# simulate_process:
#   process_type    : "geometric", "EGPP_power", "EGPP_qpower"
#   proc_params     : 리스트로 파라미터 지정
#                     geometric   → list(a = ...)
#                     EGPP_power  → list(delta = ...)
#                     EGPP_qpower → list(q = ...)
#   baseline_dist   : "exponential", "weibull"
#   base_params     : 리스트로 베이스라인 분포 모수 지정
#                     exponential → list(lambda = ...)
#                     weibull     → list(shape = ..., scale = ...)
#   n_sim, max_n    : Monte Carlo 횟수, 저장할 이벤트 개수
#------------------------------------------------------------
simulate_process_v2 <- function(process_type,
                                proc_params,
                                baseline_dist,
                                base_params,
                                n_sim = 500,
                                max_n = 100) {

  # n번째 이벤트에서의 rate modifier 함수 (기존 규약 유지: n=1은 첫 사건)
  get_proc_modifier <- function(n) {
    switch(process_type,
      geometric   = proc_params$a^(n - 1),
      EGPP_power  = (1 + (n - 1))^proc_params$delta,
      EGPP_qpower = proc_params$q^(n - 1),
      EGPP_hybrid  = (1 + (n - 1))^proc_params$delta * proc_params$q^(n - 1),
      EGPP_n3  = (1 + (n - 1)^3)^proc_params$delta,
      stop("Unknown process_type")
    )
  }

  # 한 인터어라이벌 샘플러: event index n (>=2) 에 대한 인터어라이벌 반환
  sample_delta <- function(n) {
    rate_mod <- get_proc_modifier(n)
    switch(baseline_dist,
      exponential = {
        # rate = λ * modifier
        rexp(1, rate = base_params$lambda * rate_mod)
      },
      weibull = {
        # hazard modifier 적용: scale을 조정
        rweibull(1,
                 shape = base_params$shape,
                 scale = base_params$scale / (rate_mod^(1/base_params$shape)))
      },
      stop("Unknown baseline_dist")
    )
  }

  out <- tibble()

  for (sim in seq_len(n_sim)) {
    # 첫 사건을 0으로 취급
    times <- numeric(max_n)
    times[1] <- 0

    if (max_n >= 2) {
      # event indices 2..max_n 에 대해 인터어라이벌 생성
      deltas <- map_dbl(2:max_n, sample_delta)
      # 누적합: times[2..max_n] = times[1] + cumsum(deltas)
      times[2:max_n] <- cumsum(deltas)
    }

    out <- out %>%
      bind_rows(
        tibble(
          sim_id  = sim,
          event_n = seq_len(max_n),
          time    = times
        )
      )
  }

  # 프로세스/베이스 파라미터 정보 붙여서 반환
  out %>%
    mutate(
      process_type  = process_type,
      baseline_dist = baseline_dist,
      !!!proc_params,
      !!!base_params
    )
}

```

```{r}
simulate_hawkes <- function(lambda0,
                            alpha,
                            beta,
                            n_sim = 500,
                            max_n = 100) {
  # 결과를 쌓을 tibble
  out <- tibble(sim_id = integer(),
                event_n = integer(),
                time    = double())
  
  for (sim in seq_len(n_sim)) {
    # 1) 초기화
    t_curr     <- 0
    past_times <- 0 ###
    times      <- numeric(max_n)
    
    # 2) n=1..max_n 사건 시점 생성
    for (n in seq_len(max_n-1)) { ###
      repeat {
        # (a) 현재 시간 t_curr 에서 상한강도 λ*
        lambda_star <- lambda0 + alpha * sum(exp(-beta * (t_curr - past_times)))
        #lambda_star <- lambda0 + alpha * sum(exp(beta * (t_curr - past_times)))
        
        # (b) 지수분포 Δ 샘플링 (inverse‐CDF)
        U1 <- runif(1)
        delta <- -log(U1) / lambda_star
        t_prop <- t_curr + delta
        
        # (c) 제안 시점의 실제 강도 λ(t_prop)
        lambda_tprop <- lambda0 + alpha * sum(exp(-beta * (t_prop - past_times)))
        #lambda_tprop <- lambda0 + alpha * sum(exp(beta * (t_prop - past_times)))
        
        # (d) thinning: 채택확률 비교
        if (runif(1) <= lambda_tprop / lambda_star) {
          # 채택
          times[n+1]     <- t_prop ###
          past_times   <- c(past_times, t_prop)
          t_curr       <- t_prop
          break
        }
        # 거절 시: 시간만 갱신하고 다시 제안
        t_curr <- t_prop
      }
    }
    
    # 시뮬레이션 결과 누적
    out <- out %>%
      bind_rows(
        tibble(
          sim_id  = sim,
          event_n = seq_len(max_n),
          time    = times,
          a = alpha,
          b = beta,
          lambda = lambda0
        )
      )
  }
  
  out
}
```


## 3. Explosion-time simulations: geometric process (Table 3)

### Geometric
```{r}
# ————————————————
# 2) 시뮬레이션 파라미터 설정
# ————————————————
a_vals     <- c(2, 3, 5, 8)   # geometric 파라미터 후보
lambda_vals <- c(0.0001, 0.001, 0.01) 
param_grid <- expand_grid(
  a      = a_vals,
  lambda = lambda_vals
)

n_sim       <- 1000           # Monte-Carlo 반복 횟수
max_n       <- 100             # 저장할 이벤트(고장) 개수


# ————————————————
# 3) geometric 프로세스만 돌리기
# ————————————————
set.seed(1221)    
geo_results <- param_grid %>%
  pmap_dfr(function(a, lambda) {
    simulate_process_v2(
      process_type  = "geometric",
      proc_params   = list(a = a),
      baseline_dist = "exponential",
      base_params   = list(lambda = lambda),
      n_sim         = 1000,
      max_n         = 100
    ) %>%
      mutate(a = a, lambda = lambda)
  })


# ————————————————
# 4) Explosion time(=100번째 고장 시점)만 뽑아서 요약하기
# ————————————————
explosion_df <- geo_results %>%
  filter(event_n == max_n)   # event_n == 50인 마지막 시점만

summary_geo <- explosion_df %>%
  group_by(a, lambda) %>%
  summarise(
    mean_T   = mean(time),
    Q1        = quantile(time, 0.25),
    median_T  = median(time),
    Q3        = quantile(time, 0.75),
    ci_low   = quantile(time, 0.025),
    ci_high  = quantile(time, 0.975),
    .groups  = "drop"
  ) %>%
  arrange(a, lambda)
summary_geo
```

## 4. Explosion-time simulations: EGPP models (Table 4)

### EGPP 
```{r}
# ————————————————
# 2) 시뮬레이션 파라미터 설정
# ————————————————
delta_vals <- c(2,3,5,8)   # EGPP 파라미터 후보
lambda_vals <- c(0.0001, 0.001, 0.01) 
param_grid <- expand_grid(
  delta      = delta_vals,
  lambda = lambda_vals
)

n_sim       <- 1000           # Monte-Carlo 반복 횟수
max_n       <- 100             # 저장할 이벤트(고장) 개수


# ————————————————
# 3) EGPP 프로세스만 돌리기
# ————————————————
set.seed(1221)    
egpp_results <- param_grid %>%
  pmap_dfr(function(delta, lambda) {
    simulate_process_v2(
      process_type  = "EGPP_power",
      proc_params   = list(delta = delta),
      baseline_dist = "exponential",
      base_params   = list(lambda = lambda),
      n_sim         = 1000,
      max_n         = 100
    ) %>%
      mutate(delta = delta, lambda = lambda)
  })


# ————————————————
# 4) Explosion time(=100번째 고장 시점)만 뽑아서 요약하기
# ————————————————
explosion_df <- egpp_results %>%
  filter(event_n == max_n)   # event_n == 50인 마지막 시점만

summary_egpp <- explosion_df %>%
  group_by(delta, lambda) %>%
  summarise(
    mean_T   = mean(time),
    Q1        = quantile(time, 0.25),
    median_T  = median(time),
    Q3        = quantile(time, 0.75),
    ci_low   = quantile(time, 0.025),
    ci_high  = quantile(time, 0.975),
    .groups  = "drop"
  ) %>%
  arrange(delta, lambda)
summary_egpp
```

# MLE Simulation
```{r}
library(survival); library(broom); library(ggplot2)

# ---------- 사용자 설정 (필요시 수정) ----------
set.seed(1221)
n_sim   <- 1000
target_n<- 100        # explosion 정의: N(t) >= target_n
max_n   <- 100        # 시뮬레이션에서 생성하는 최대 event 수 (당신 함수에 맞춤)
Tcut    <- Inf        # 검열 시점: Inf 이면 시뮬레이션 마지막 시간 사용
# 모델별 추정/사용 파라미터 (예: as-fitted or chosen)
params_geo   <- list(a = exp(opt1$par)[[2]], lambda = exp(opt1$par)[[1]])            # 예시: 바꿔서 사용
params_egpp  <- list(delta = exp(opt2$par)[[2]], lambda = exp(opt2$par)[[1]])    # 예시
params_egpp2  <- list(delta = exp(opt4$par)[[2]], lambda = exp(opt4$par)[[1]])    # 예시
params_hawkes<- list(lambda0 = exp(opt5$par)[[1]], alpha = exp(opt5$par)[[2]], beta = exp(opt5$par)[[3]]) # 예시
# -------------------------------------------------

# helper: 한 시뮬레이션 결과에서 explosion time (or censored) 추출
get_explosion_from_times <- function(times, target_n, Tcut = Inf) {
  times <- times[!is.na(times)]
  # if we have event times labeled by index, we need the target_n-th time
  if (length(times) >= target_n) {
    return(list(time = times[target_n], status = 1)) # observed
  } else {
    # censored at last observed time or Tcut
    censor_time <- if (is.finite(Tcut)) min(max(times, na.rm=TRUE), Tcut) else max(times, na.rm = TRUE)
    if (is.nan(censor_time)) censor_time <- NA_real_
    return(list(time = censor_time, status = 0))     # censored
  }
}

# wrapper: many sims for geometric/egpp using your simulate_process()
simulate_many_process <- function(process_type, proc_params, baseline_dist, base_params, n_sim=1000, max_n=200, target_n=100, Tcut=Inf) {
  out <- data.frame(sim_id = integer(), time = double(), status = integer(), stringsAsFactors = FALSE)
  for (i in seq_len(n_sim)) {
    sim_tb <- simulate_process_v2(process_type = process_type,
                               proc_params = proc_params,
                               baseline_dist = baseline_dist,
                               base_params = base_params,
                               n_sim = 1,
                               max_n = max_n)
    times <- sim_tb$time
    ex <- get_explosion_from_times(times, target_n = target_n, Tcut = Tcut)
    out <- rbind(out, data.frame(sim_id = i, time = ex$time, status = ex$status))
  }
  out$process <- process_type
  return(out)
}

# wrapper for hawkes (your simulate_hawkes returns tibble with $time)
simulate_many_hawkes <- function(lambda0, alpha, beta, n_sim=1000, max_n=200, target_n=100, Tcut=Inf) {
  out <- data.frame(sim_id = integer(), time = double(), status = integer(), stringsAsFactors = FALSE)
  for (i in seq_len(n_sim)) {
    sim_tb <- simulate_hawkes(lambda0 = lambda0, alpha = alpha, beta = beta, n_sim = 1, max_n = max_n)
    times <- sim_tb$time
    ex <- get_explosion_from_times(times, target_n = target_n, Tcut = Tcut)
    out <- rbind(out, data.frame(sim_id = i, time = ex$time, status = ex$status))
  }
  out$process <- "hawkes"
  return(out)
}
```

```{r}
seed_num = 1221

set.seed(seed_num)
geo_df  <- simulate_many_process("geometric", proc_params = list(a = params_geo$a), baseline_dist = "exponential", base_params = list(lambda = params_geo$lambda), n_sim = n_sim, max_n = max_n, target_n = target_n, Tcut = Tcut)

set.seed(seed_num)
egpp_df <- simulate_many_process("EGPP_power", proc_params = list(delta = params_egpp$delta), baseline_dist = "exponential", base_params = list(lambda = params_egpp$lambda), n_sim = n_sim, max_n = max_n, target_n = target_n, Tcut = Tcut)

set.seed(seed_num)
egpp2_df <- simulate_many_process("EGPP_n3", proc_params = list(delta = params_egpp2$delta), baseline_dist = "exponential", base_params = list(lambda = params_egpp2$lambda), n_sim = n_sim, max_n = max_n, target_n = target_n, Tcut = Tcut)

set.seed(seed_num)
haw_df  <- simulate_many_hawkes(lambda0 = params_hawkes$lambda0, alpha = params_hawkes$alpha, beta = params_hawkes$beta, n_sim = n_sim, max_n = max_n, target_n = target_n, Tcut = Tcut)

all_df <- rbind(geo_df, egpp_df, egpp2_df, haw_df)
all_df$time[is.infinite(all_df$time)] <- NA_real_
```

## 5. Summary statistics of the explosion time T  (Table 5)
```{r}
# 2) 결과 요약 (median, mean of observed times, censor rate)
summ <- function(df) {
  n_sim = nrow(df)
  n_obs = sum(df$status == 1, na.rm=TRUE)
  censor_rate = 1 - n_obs/n_sim
  mean_t = mean(df$time[df$status==1], na.rm=TRUE)
  med_t  = quantile(df$time[df$status==1], .50, na.rm=TRUE)[[1]]
  q25 = quantile(df$time[df$status==1], .25, na.rm=TRUE)[[1]]
  q75 = quantile(df$time[df$status==1], .75, na.rm=TRUE)[[1]]
  round(c(n_sim = n_sim, n_obs = n_obs, censor_rate = censor_rate, mean = mean_t, "25%" = q25, "50%" = med_t, "75%" = q75),2)
}
rbind(geometric = summ(geo_df), EGPP = summ(egpp_df), EGPP2 = summ(egpp2_df), hawkes = summ(haw_df))
```


## 6. Pdf’s of the explosion time T  (Figure 6)
```{r}
# 3) PDF(밀도) 그리기 — 관측된(uncensored) 시간만 사용
dens_df <- do.call(rbind, lapply(split(all_df, all_df$process), function(df){
  obs <- df$time[df$status == 1 & !is.na(df$time)]
  from_x <- 0
  to_x   <- max(obs, na.rm=TRUE) * 1.05   # 끝에 약간 여유 둠
  bw0 <- bw.nrd0(obs)
  den <- density(obs, bw = bw0,
               kernel = "gaussian",
               from = from_x,
               to   = to_x,
               n    = 512)
  data.frame(process = unique(df$process), x = den$x, y = den$y)
}))

## 색깔 버전 ##
# 라벨 문자열 (plotmath 문법)
label_strs <- c(
  "EGPP~with~r(n)==(1 + n^3)^delta",   # EGPP with r(n)=(1+n^3)^δ
  "EGPP~with~r(n)==(1 + n)^delta",     # EGPP with r(n)=(1+n)^δ
  "Geometric",                         # plain text
  "Hawkes"                             # plain text
)

## 흑백 버전 ##
ggplot(dens_df, aes(x = x, y = y, linetype = process, group = process)) +
  geom_line(size = 0.6, color = "black") +   # 선 굵기 조절, 색은 검정 고정
  # geom_area 제거 — 흑백에서 영역색은 해석 혼동을 야기하므로 삭제 권장
  scale_linetype_manual(
    values = c("dotted", "dashed", "twodash", "solid"), 
    name = "Model",
    labels = c(
    TeX("EGPP with $r(n)=(1+n^3)^\\delta$"),
    TeX("EGPP with $r(n)=(1+n)^\\delta$"),
    "Geometric",
    "Hawkes") # 범례 제목
  ) +
  labs(x = "Time (sec)", y = "Density") +
  coord_cartesian(xlim = c(NA,25000)) + 
  theme_minimal() + 
  theme(legend.position = c(0.65,0.9),
        legend.justification = c(0, 1), 
        legend.background = element_rect(fill = alpha("white", 0.85), colour = "black",size=0.2),
        legend.key.width = unit(1.2, "cm"),
        panel.background = element_blank(),
        legend.text  = element_text(size = 12),
        legend.title = element_text(size = 12),
        axis.title = element_text(size = 14),
        axis.title.x = element_text(margin = margin(t = 8)),
        axis.title.y = element_text(margin = margin(r = 8)),
        axis.text = element_text(size = 12))
```



## 6. Tail risk summary  (Table 6)
```{r}
tail_risk_summary <- all_df %>%
    group_by(process) %>%
    summarize(
        n_sim = n(),
        mu    = mean(time),
        sd    = sd(time),
        thr_high3 = mu + 3 * sd,
        thr_low3  = mu - 3 * sd,
        thr_high2 = mu + 2 * sd,
        thr_low2  = mu - 2 * sd,
        thr_high = mu + sd,
        thr_low  = mu - sd,
        p_gt_mu3sd = mean(time > thr_high3),
        
        p_gt_mu2sd = mean(time > thr_high2),
         p_gt_mu1sd = mean(time > thr_high),
        p_lt_mu1sd = ifelse(thr_low <= 0, 0, mean(time < thr_low)),
        p_lt_mu2sd = ifelse(thr_low2 <= 0, 0, mean(time < thr_low2)), 
        p_lt_mu3sd = ifelse(thr_low3 <= 0, 0, mean(time < thr_low3))
    )

as.data.frame(tail_risk_summary)[,-c(2:10)]
```

# Average lines

## Geometric
```{r}
# --- 설정 (너가 이미 가지고 있는 값들) ---
true_lambda <- exp(opt1$par)[1]
true_a      <- exp(opt1$par)[2]

n_paths  <- 100
n_events <- nrow(df2) + 1   # 관측에 사용한 event 수 (너가 쓰던 기준)
seed_start <- 1221

# --- 1) 원래 방식: 100개 path 생성 (이들을 "데이터"로 사용) ---
list_times <- vector("list", n_paths)
list_Tn    <- vector("list", n_paths)

for(k in seq_len(n_paths)) {
  set.seed(seed_start + k)
  sim <- simulate_process_v2(
    process_type  = "geometric",
    proc_params   = list(a = true_a),
    baseline_dist = "exponential",
    base_params   = list(lambda = true_lambda),
    n_sim         = 1,
    max_n         = n_events
  )
  times_k <- sim %>% arrange(event_n) %>% pull(time)   # 길이 = n_events
  list_times[[k]] <- times_k
  list_Tn[[k]]    <- diff(times_k)                     # 길이 = n_events-1
}


orig_df1 <- bind_rows(
  lapply(seq_len(n_paths), function(k) tibble(run = paste0("orig_",k),
                                              event = seq_len(n_events),
                                              time = list_times[[k]]))
)

mean_orig_df1 = orig_df1 %>% group_by(event) %>% summarise(meantime = mean(time))
```

## EGPP
```{r}
# --- 설정 (너가 이미 가지고 있는 값들) ---
true_lambda <- exp(opt2$par)[[1]]
true_delta  <- exp(opt2$par)[[2]]

n_paths  <- 100
n_events <- nrow(df2) + 1   # 관측에 사용한 event 수 (너가 쓰던 기준)
seed_start <- 1221

# --- 1) 원래 방식: 100개 path 생성 (이들을 "데이터"로 사용) ---
list_times <- vector("list", n_paths)
list_Tn    <- vector("list", n_paths)

for(k in seq_len(n_paths)) {
  set.seed(seed_start + k)
  sim <- simulate_process_v2(
    process_type  = "EGPP_power",
    proc_params   = list(delta = true_delta),
    baseline_dist = "exponential",
    base_params   = list(lambda = true_lambda),
    n_sim         = 1,
    max_n         = n_events
  )
  times_k <- sim %>% arrange(event_n) %>% pull(time)   # 길이 = n_events
  list_times[[k]] <- times_k
  list_Tn[[k]]    <- diff(times_k)                     # 길이 = n_events-1
}


orig_df2 <- bind_rows(
  lapply(seq_len(n_paths), function(k) tibble(run = paste0("orig_",k),
                                              event = seq_len(n_events),
                                              time = list_times[[k]]))
)

mean_orig_df2 = orig_df2 %>% group_by(event) %>% summarise(meantime = mean(time))
```

## EGPP n3
```{r}
# --- 설정 (너가 이미 가지고 있는 값들) ---
true_lambda <- exp(opt4$par)[[1]]
true_delta  <- exp(opt4$par)[[2]]

n_paths  <- 100
n_events <- nrow(df2) + 1   # 관측에 사용한 event 수 (너가 쓰던 기준)
seed_start <- 1221

# --- 1) 원래 방식: 100개 path 생성 (이들을 "데이터"로 사용) ---
list_times <- vector("list", n_paths)
list_Tn    <- vector("list", n_paths)

for(k in seq_len(n_paths)) {
  set.seed(seed_start + k)
  sim <- simulate_process_v2(
    process_type  = "EGPP_n3",
    proc_params   = list(delta = true_delta),
    baseline_dist = "exponential",
    base_params   = list(lambda = true_lambda),
    n_sim         = 1,
    max_n         = n_events
  )
  times_k <- sim %>% arrange(event_n) %>% pull(time)   # 길이 = n_events
  list_times[[k]] <- times_k
  list_Tn[[k]]    <- diff(times_k)                     # 길이 = n_events-1
}


orig_df3 <- bind_rows(
  lapply(seq_len(n_paths), function(k) tibble(run = paste0("orig_",k),
                                              event = seq_len(n_events),
                                              time = list_times[[k]]))
)

mean_orig_df3 = orig_df3 %>% group_by(event) %>% summarise(meantime = mean(time))
```

## 7. The average of 100 simulated paths of the fitted models (Figure 5)
```{r}
mean1 <- mean_orig_df1   # geometric
mean2 <- mean_orig_df2   # egpp_power
mean3 <- mean_orig_df3   # egpp_n3

# 통일된 형식: time, sequence, process
df_means <- bind_rows(
  mean1 %>% rename(sequence = event, time = meantime) %>% mutate(process = "Geometric"),
  mean2 %>% rename(sequence = event, time = meantime) %>% mutate(process = "EGPP (1+n)^δ"),
  mean3 %>% rename(sequence = event, time = meantime) %>% mutate(process = "EGPP (1+n^3)^δ")
)

actual_df <- tibble(
  time     = second,                
  sequence = seq_along(second)      
)
df_actual <- actual_df %>% mutate(process = "Real data")

all_plot_df <- bind_rows(df_means, df_actual %>% select(time, sequence, process))

# ---------- Plot (흑백버전)----------
p <- ggplot(all_plot_df, aes(x = time, y = sequence, linetype = process)) +
  geom_step(size = 0.8) +
  geom_step(data = filter(all_plot_df, process == "Real data"),
            aes(x = time, y = sequence),
            color = "black", size = 1.1, inherit.aes = FALSE) +
  scale_linetype_manual(
    values = c("dotted", "dashed", "twodash", "solid"), 
    name = "Model",
    labels = c(
    TeX("EGPP with $r(n)=(1+n)^\\delta$"),
    TeX("EGPP with $r(n)=(1+n^3)^\\delta$"),
    "Geometric",
    "Real data") # 범례 제목
  ) +
  labs(x = "Time (sec)", y = "Average of cumulative number of failures N(t)",
       color = "Process", linetype = "Process") +
  theme_minimal() +
  theme(legend.position = "right",
        legend.background = element_rect(fill = alpha("white", 0.85), colour = "black",size=0.2),
        legend.key.width = unit(1.2, "cm"),
        panel.background = element_blank(),
        legend.text  = element_text(size = 12),
        legend.title = element_text(size = 12),
        axis.title = element_text(size = 14),
        axis.title.x = element_text(margin = margin(t = 8)),
        axis.title.y = element_text(margin = margin(r = 8)),
        axis.text = element_text(size = 12))

print(p)
```

